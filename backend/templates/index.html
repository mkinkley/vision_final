<!DOCTYPE html>

<meta charset="utf-8" />
<html>
<head>
    <style>
        body { margin: 0; }
        canvas { width: 100%; position: absolute; top: 0; }
        video { width: 100%; }
    </style>
</head>
<body>
<video autoplay></video>
<script src="http://cdnjs.cloudflare.com/ajax/libs/mathjs/2.4.0/math.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js"></script>
      <script type="text/javascript" charset="utf-8">
          var scene, camera, renderer, light, earthMesh, earthRotY = 0;
          var currX = 0;
          var currY = 0;
          var positionHistory = [];
          var lastPos, diffMove;
          var tmpMesh;
          var wide, length;
          var targetX;
          var group;
          var particle;
          var targetY;
          var scale = 0;
          var lastScale;
          var lastX = 0;
          var lastY = 0;
          var timeBetween = 1;
          var launch = 0;
          var prelaunch = 0;
          var launchDir = 0;
          var launchMag = 0;
          var finishSpotX = 0;
          var finishSpotY = 0;
          var t = 0;
          var preLaunchX, preLaunchY, velocity;


function initScene(width, height) {
    scene = new THREE.Scene();
    // Setup cameta with 45 deg field of view and same aspect ratio
    camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    wide = width;
    length = height;
    // Set the camera to 400 units along `z` axis
    camera.position.set(0, 0, 400);


    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);
}

function initLight() {
    light = new THREE.SpotLight(0xffffff);
    // Position the light slightly to a side to make shadows look better.
    light.position.set(400, 100, 1000);
    light.castShadow = true;
    scene.add(light);
}

function initParticles() {
    var earthMaterial = new THREE.MeshLambertMaterial({color: 0xF46CE6});
    // Create a sphere 25 units in radius and 16 segments
    // both horizontally and vertically.
    var earthGeometry = new THREE.SphereGeometry(25, 16, 16);
    earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
    earthMesh.receiveShadow = true;
    earthMesh.castShadow = true;
    // Add Earth to the scene
    scene.add(earthMesh);
}

function initEarth() {
    // Load Earth texture and create material from it

    var earthMaterial = new THREE.MeshLambertMaterial({color: 0xF46CE6});
    // Create a sphere 25 units in radius and 16 segments
    // both horizontally and vertically.
    var earthGeometry = new THREE.SphereGeometry(25, 16, 16);
    earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
    earthMesh.receiveShadow = true;
    earthMesh.castShadow = true;
    // Add Earth to the scene
    scene.add(earthMesh);

     var PI2 = Math.PI * 2;
       group = new THREE.Object3D();
      scene.add(group);
      for (var i = 0; i < 1000; i++) {
        var material = new THREE.SpriteMaterial({
          color: Math.random() * 0x808008 + 0x808080
        });
        particle = new THREE.Sprite(material);
        particle.position.x = Math.random() * 100;
        if (i % 3 === 0) {
            particle.position.x = particle.position.x * -1;

        }
        if (i % 2 === 0) {
            if (particle.position.x < 0) {
                particle.position.x -= 100;
            } else {
                particle.position.x += 100;
            }
        }
        console.log(particle.position.x);
        particle.position.y = Math.random() * 250 - 150;
        particle.position.z = Math.random() * 250 - 50;
        particle.scale.x = particle.scale.y = Math.random() * 10 + 10;
        group.add(particle);
      }
}

function initEarth2() {
    // Load Earth texture and create material from it
    var earthMaterial = new THREE.MeshLambertMaterial({color: 0xF46CE6});
    // Create a sphere 25 units in radius and 16 segments
    // both horizontally and vertically.
    var earthGeometry = new THREE.SphereGeometry(25, 16, 16);
    earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
    earthMesh.receiveShadow = true;
    earthMesh.castShadow = true;
    // Add Earth to the scene
    scene.add(earthMesh);
}

// Update position of objects in the scene
function update() {
    /*
    launch = 0;
    if (positionHistory.length === 0) {
        return;
    }
    earthRotY += 0.007;
    earthMesh.rotation.y = earthRotY;
    // screen only starts at like 500 so have to start there or set
    // to where we want otherwise
    goal_x = 500;
    goal_y = currY;
    if (currX >= 500) {
        goal_x = currX;
    }
    // if its less than 1000 then we use one equation to get the new
    // x coord
    if (goal_x <= 1000) {
        goal_x = 78038850 + ((-404.7419 - 78038850) /
            (1 + Math.pow((goal_x /2106957), 1.593)));

    } else if (goal_x > 1000) {
        goal_x = 903 + ((-28780020 - 903) /
            (1 + Math.pow((goal_x /0.03741775), 1.0178)));

    }

    if (currY > (length/3)) {
        goal_y = currY - 2*(length / 5);
    } else {
        goal_y = -currY + length/4;
    }
    if (launch) {
        t++;
        /*
        var finishY = finishSpotY;
        var prelaunchYTransfer = preLaunchY;
        if (finishY > (length/3)) {
            finishY = finishY - 2*(length / 5);
        } else {
            finishY = -finishY + length/4;
        }
        if (prelaunchYTransfer > (length/3)) {
            prelaunchYTransfer =prelaunchYTransfer- 2*(length / 5);
        } else {
            prelaunchYTransfer = -prelaunchYTransfer + length/4;
        }
        console.log("sin is: " + Math.sin(launchDir));
        var y = prelaunchYTransfer + velocity * t * Math.sin(launchDir)
                            - (1/2 * 9.18 * t^2);
        var finishX = finishSpotX;
        var prelaunchXTransfer = preLaunchX;
        if (finishX < 500) {
            finishX = 500;
        }
        if (finishX <= 1000) {
            finishX = 78038850 + ((-404.7419 - 78038850) /
            (1 + Math.pow((finishX /2106957), 1.593)));

        } else if (finishX > 1000) {
            finishX = 903 + ((-28780020 - 903) /
                (1 + Math.pow((finishX /0.03741775), 1.0178)));
        }
        if (prelaunchXTransfer < 500) {
            prelaunchXTransfer = 500;
        }
        if (prelaunchXTransfer <= 1000) {
            prelaunchXTransfer = 78038850 + ((-404.7419 - 78038850) /
            (1 + Math.pow((prelaunchXTransfer /2106957), 1.593)));

        } else if (prelaunchXTransfer > 1000) {
            prelaunchXTransfer = 903 + ((-28780020 - 903) /
                (1 + Math.pow((prelaunchXTransfer /0.03741775), 1.0178)));
        }
        var x = prelaunchXTransfer + velocity * t * Math.cos(launchDir);
        if (Math.abs(x - finishX) < 3) {
            launch = 0;
            preLaunch = 0;
        }

        var prelaunchYTransfer = preLaunchY;
        if (prelaunchYTransfer > (length/3)) {
            prelaunchYTransfer =prelaunchYTransfer- 2*(length / 5);
        } else {
            prelaunchYTransfer = -prelaunchYTransfer + length/4;
        }
        var prelaunchXTransfer = preLaunchX;
        if (prelaunchXTransfer < 500) {
            prelaunchXTransfer = 500;
        }
        if (prelaunchXTransfer <= 1000) {
            prelaunchXTransfer = 78038850 + ((-404.7419 - 78038850) /
            (1 + Math.pow((prelaunchXTransfer /2106957), 1.593)));

        } else if (prelaunchXTransfer > 1000) {
            prelaunchXTransfer = 903 + ((-28780020 - 903) /
                (1 + Math.pow((prelaunchXTransfer /0.03741775), 1.0178)));
        }
        var velocityCos = 0.07 * t * Math.cos(Math.PI/ 3);
        var velocitySin = 0.07 * t * Math.sin(Math.PI / 3);
        var x = prelaunchXTransfer;
        var y = prelaunchYTransfer;
        if (prelaunchXTransfer > 0) {
            x -= velocityCos;
        } else {
            x += velocityCos;
        }
        if (prelaunchYTransfer > 0) {
            y -= velocitySin - .5 * 9.81 * t^2;
        } else {
            y += velocitySin - .5 * 9.81 * t^2;
        }
        console.log(" x is: " + x + " and y is: " + y);
        if (x < -wide/4 || x > wide/4) {
            launch = 0;
            prelaunch = 0;
            x = x < -wide/4 ? -wide/4 : wide/4;
        }
        if (y < -length / 6 || y > length/6) {
            launch = 0;
            prelaunch = 0;
            y = y < -length/6 ? -length/6 : length/6;
        }
        console.log(" x is: " + x + " and y is: " + y);
        earthMesh.position.x = x;
        earthMesh.position.y = y;
        earthMesh.scale.set(scale, scale, scale);

    } else {
        var position = {x: lastX, y: lastY};
        var target = {x: goal_x, y: goal_y};
        var tween = new TWEEN.Tween(position).to(target, 3000);

        tween.onUpdate(function () {
            earthMesh.position.x = position.x;
            earthMesh.position.y = position.y;
        });
        earthMesh.position.x = goal_x;
        earthMesh.position.y = goal_y;
        earthMesh.scale.set(scale, scale, scale);
    }
    var childrens = group.children;
    for (let child = 0; child < childrens.length; child++) {
        childrens[child].position.x += lastX - currX;
        childrens[child].position.y += lastY - currY;

    }
    */
}

// Redraw entire scene
function render() {
    update();
    renderer.setClearColor(0x000000, 0);
    renderer.render(scene, camera);
    // Schedule another frame
    requestAnimationFrame(render);
}

document.addEventListener('DOMContentLoaded', function(e) {
    // Initialize everything and start rendering
    initScene(window.innerWidth, window.innerHeight);
    //initEarth();
    initParticles();
    initLight();
    // Start rendering the scene
    requestAnimationFrame(render);
});

var videoElm = document.querySelector('video');
// Make sure the video fits the window.
var constrains = { video: { mandatory: { minWidth: window.innerWidth }}};

if (navigator.getUserMedia) {
    navigator.getUserMedia(constrains, function(stream) {
        videoElm.src = window.URL.createObjectURL(stream);
        // When the webcam stream is ready get it's dimensions.
        videoElm.oncanplay = function() {
            requestAnimationFrame(render);
        }
    }, function() {});
}
            var socket = io.connect('http://localhost:5000');
            socket.on('connect', function() {
                 console.log('connected');
            });
            socket.on('message', function(data) {
                 positionHistory.push({x: data.x,
                 y: data.y});
                 lastX = currX;
                 lastY = currY;
                 currX = data.x;
                 currY = data.y;

                 if (positionHistory.length > 10) {
                     positionHistory.shift();
                 }
                 var xCoords = [], yCoords = [];
                 for (var i = math.max(positionHistory.length - 1, 0); i < positionHistory.length; i++) {
                    xCoords.push(positionHistory[i].x);
                    yCoords.push(positionHistory[i].y);
                 }

                 var posX = math.mean(xCoords);
                 var posY = math.mean(yCoords);
                 targetY = posY / 5;
                 targetX = posX / 5;
                 //console.log("targets:");
                 //console.log(targetY, targetX);

                 var targetPos = [posX, posY];
                 if (!lastPos) {
                    lastPos = targetPos;
                 }
                 if (!lastScale) {
                     lastScale = data.area;
                 }
                 diffMove = [(targetPos[0] - lastPos[0]) / 4,
                     (targetPos[1] - lastPos[1]) / 4];

                 console.log(data);
                 scale = data.area/lastScale;
                 //console.log(scale);
                 //console.log("curr pos");
                 //console.log(earthMesh.position.x, earthMesh.position.y)

            });
      </script>
</body>
</html>